\documentclass{book}

\usepackage{etoolbox}

\makeatletter
\def\subtitle#1{\gdef\@subtitle{#1}}
\patchcmd\maketitle
  {{\LARGE \@title \par}}
  {{\LARGE \@title \par}%
   \vskip 1.5em
   {\Large \@subtitle \par}}
\makeatother

\usepackage[utf8x]{inputenc}
\usepackage{amsmath,mathtools}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{appendix}
\usepackage{enumitem}
\usepackage{bm}
\usepackage{multicol}
\usepackage{geometry}
\usepackage{colortbl}
\usepackage{changepage}
\usepackage{color}
\usepackage{mathrsfs}
\usepackage{bigints}
\usepackage{pdflscape}
\usepackage{adjustbox}
\usepackage{tocloft}
\usepackage{lscape}
\usepackage[dvipsnames]{xcolor}
\usepackage[colorlinks=true,
            linkcolor=blue,
            urlcolor=blue,
            citecolor=blue]{hyperref}

\sloppy
\usepackage{tikz, lipsum}% http://ctan.org/pkg/{pgf,lipsum}
\newcommand*{\chapnumfont}{\normalfont\sffamily\huge\bfseries}
\newcommand*{\printchapternum}{
  \begin{tikzpicture}
    \draw[fill,color=gray75] (0,0) rectangle (2cm,2cm);
    \draw[color=white] (1cm,1cm) node { \chapnumfont\thechapter };
  \end{tikzpicture}
}
\newcommand*{\chaptitlefont}{\normalfont\sffamily\Huge\bfseries}
\newcommand*{\printchaptertitle}[1]{\flushright\chaptitlefont#1}

\makeatletter
% \@makechapterhead prints regular chapter heading.
% Taken directly from report.cls and modified.
\def\@makechapterhead#1{%
  \vspace*{50\p@}%
  {\parindent \z@ \raggedleft
    \ifnum \c@secnumdepth >\m@ne
        \printchapternum
        \par\nobreak
        \vskip 20\p@
    \fi
    \interlinepenalty\@M
    \printchaptertitle{#1}\par\nobreak
    \vskip 40\p@
  }}
% \@makeschapterhead prints starred chapter heading.
% Taken directly from report.cls and modified.
\def\@makeschapterhead#1{%
  \vspace*{50\p@}%
  {\parindent \z@ \raggedleft
    \interlinepenalty\@M
    \printchaptertitle{#1}\par\nobreak
    \vskip 40\p@
  }}
\makeatother

\makeatletter\@addtoreset{chapter}{part}\makeatother%

\renewcommand\contentsname{}

\definecolor{gray75}{gray}{0.75}

\title{\Huge \bfseries\sffamily Diffusing ideas}
\subtitle{\Large \bfseries\sffamily \color{gray75} Software, noise and building mathematical toys}
\author{\bfseries\sffamily Robert J. Hardwick}
\date{\today}
\begin{document}
\maketitle
\frontmatter

\chapter*{Introduction}

\emph{Diffusing ideas} records a journey of research exploration and software development over several years. It is the output of interrelated projects which have mainly been focused on generalising the software interfaces for simulation, statistical inference, manipulation and automated control of stochastic phenomena as much as possible. Therefore, in order to manifest these ideas into reality, these projects have involved designing and building a lot of new open-source scientific software which is predominantly written in the \href{https://www.python.org/}{Python} and \href{https://go.dev/}{Go} progamming languages. 

The main motivation behind developing these computational tools is to form a convenient foundation of software modules from which anyone can build loads of new applications. I also hope that the resulting framework will make research into new phenomena a much more efficient experience for anyone, regardless of their scientific background.  

Having just stated all this altruistic-sounding stuff, I would be remiss if I left listing my motivations for writing this book at that. The necessity for testing the software has provided a wonderful excuse to study, play with and invent new derivatives of an extensive range of mathematical toy models with which I intend to illustrate the remarkable cross-disciplinary applicability of stochastic processes. The possibilities really seem endless! And as such, I have tried to write this book so that is reads more like an adventure for the curious (and perhaps fairly mathematically-inclined) software developer, as opposed to a formal academic publication. I hope you, the reader, will find these mathematical model digressions interesting.

A quick note on the software; any software that I describe in this book (including the \href{https://github.com/umbralcalc/diffusing-ideas}{software which compiles the book itself}) will always be shared under a \href{https://opensource.org/licenses/MIT}{MIT License} in a public Git repository.\footnote{The repositories will always be somewhere on this list: \href{https://github.com/umbralcalc?tab=repositories}{https://github.com/umbralcalc?tab=repositories}.} Forking these repositories and submitting pull requests for new features or applications is strongly encouraged too, though I apologise in advance if I don't follow these up very quickly as all of this work has to be conducted independently in my free time outside of work hours.

No quest would be complete without a guide, so to end this introduction, I think it makes the most sense to outline the key milestones and their motivations within the context of the overall research project. My core aims, which comprise the four major parts of this book, are answers to the following set of interdependent research questions:

\begin{enumerate}[leftmargin=2.5\parindent] 
\item[{\bfseries\sffamily Part 1.}]{How do we simulate a general set of stochastic phenomena?}
\item[{\bfseries\sffamily Part 2.}]{How do we then learn/identify the answer to {\bfseries\sffamily Part 1} from real-world data?}
\item[{\bfseries\sffamily Part 3.}]{How do we simulate a general set of control policies to interact with the answer to {\bfseries\sffamily Part 1}?}
\item[{\bfseries\sffamily Part 4.}]{How do we then optimise the answer to {\bfseries\sffamily Part 3} to achieve a specified control objective?} 
\end{enumerate}



\chapter*{Table of contents}
\vspace*{-3cm}
{\sffamily \tableofcontents}
\mainmatter


\part*{{\sffamily {\color{gray75} Part 1.} How do we simulate a general set of stochastic phenomena?}}


\chapter{\sffamily Building a generalised simulator}

{\bfseries\sffamily Concept.} To design and build a generalised simulation engine that is able to generate samples from a `Pokédex' of possible stochastic processes that a researcher might encounter. A `Pokédex' here is just my fanciful description for a very general class of multidimensional stochastic processes that pop up everywhere in taming the mathematical wilds of real-world phenomena, and which also leads to a name for the software itself: the `stochadex'. With such a thing pre-built and self-contained, it can become the basis upon which to build generalised software solutions for a lot of different problems. For the mathematically-inclined, this chapter will require the introduction of a new formalism which we shall refer back to throughout the book. For the programmers, the public Git repository for the code that is described in this chapter can be found here: \href{https://github.com/umbralcalc/stochadex}{https://github.com/umbralcalc/stochadex}.

\section{\sffamily Core mathematical formalism}

Before we dive into the software, we need to define the mathematical approach that we're going to take in order to be able to describe a really general set of stochastic phenomena. From experience, it seems reasonable to start by writing down the following formula which describes iterating some arbitrary process forward in time (by one finite step) and adding a new row each to some matrices $V' \rightarrow V$ and $X' \rightarrow X$
%%
\begin{align}
X^{i}_{t+1} &= F^{i}_{t+1}(X', V', t) \label{eq:x-step-def}\\
V^{i}_{t+1} &= X^{i}_{t+1} - X^{i}_{t} \label{eq:v-step-def}\,,
\end{align}
%%
where: $i$ is an index for the dimensions of the `state' space; $t$ is the current time index for either a discrete-time process or some discrete approximation to a continuous-time process; $X$ is the next version of $X'$ after one timestep (and hence one new row has been added); $V$ as the next version of $V'$ (similarly to $X$ and $X'$); and $F^i_{t+1}(X', V', t)$ as the latest element of an arbitrary matrix-valued function.

So the basic computational idea here is to iterate the matrices $X$ and $V$ forward in time by a row, and use their previous versions ($X'$ and $V'$) as entire matrix inputs into functions which populate the elements of their latest rows. But why go to all this trouble of storing matrix inputs for previous values of the same process? For a large class of stochastic processes this memory of past values is essential to consistently construct the sample paths moving forward. This is true in particular for \emph{non-Markovian} phenomena, where the latest values don't just depend on the immediately previous ones but can depend on values which occured much earlier in the process.

Note that, based on the definition in Eq.~(\ref{eq:v-step-def}) above, the following relation is also valid
%%
\begin{align}
X^{i}_{t} &= X_{s}^{i} + \sum_{s'=s+1}^{t}V_{s'}^{i} \label{eq:x-implicit-solution} \,,
\end{align}
%%
where $s<t$.



\section{\sffamily Flavours of noise with continuous sample paths}

For \emph{Wiener process noise}, adopting the \href{https://en.wikipedia.org/wiki/It\%C3\%B4_calculus}{Itô interpretation} in this section, we can define $W^i_{t}$ is a sample from a Wiener process for each of the state dimensions indexed by $i$ and our formalism becomes
%%
\begin{align}
& X^i_{t+\delta t} = F^i_{t+\delta t}(X', t) + \textcolor{red}{W^i_{t+\delta t}-W^i_{t}}\,.
\end{align}
%%

Other interpretations of the noise are less immediately compatible with our formalism as it is currently written, e.g., \href{https://en.wikipedia.org/wiki/Stratonovich_integral}{Stratonovich} or others within the $\alpha$-family, but it seems less necessary to complicate the details of this section further, so we'll just cover these extensions at the software implementation level. Note also that we may also allow for correlations between the noises in different dimensions. 

For \emph{Geometric Brownian motion noise}, we simply have
%%
\begin{align}
& X^i_{t+\delta t} = F^i_{t+\delta t}(X', t) + \textcolor{red}{X^i_{t}(W^i_{t+\delta t}-W^i_{t})}\,.
\end{align}
%%

And say, e.g., \emph{fractional Brownian motion noise}, where $B^i_{t}({H_i})$ is a sample from a fractional Brownian motion process with Hurst exponent $H_i$ for each of the state dimensions indexed by $i$, we simply substitute again
%%
\begin{align}
& X^i_{t+\delta t} = F^i_{t+\delta t}(X', t) + \textcolor{red}{B^i_{t+\delta t}({H_i})-B^i_{t}({H_i})}\,.
\end{align}
%%

\emph{Generalised continuous noises} would take the form
%%
\begin{align}
& X^i_{t+\delta t} = F^i_{t+\delta t}(X', t) + \textcolor{red}{g^i_{t+\delta t}(X', W^i_{t+\delta t}-W^i_t, \dots)}\,,
\end{align}
%%
where $g^i_{t+\delta t}(X', W^i_{t+\delta t}-W^i_t, \dots)$ is some continuous function of its arguments which can be expanded out with \href{https://en.wikipedia.org/wiki/It\%C3\%B4\%27s_lemma}{Itôs Lemma}.


\section{\sffamily Flavours of noise with discontinuous sample paths}

\emph{Jump process noises} generally could take the form
%%
\begin{align}
& X^i_{t+\delta t} = F^i_{t+\delta t}(X', t) + \textcolor{red}{J^i_{t+\delta t}(X', \dots )}\,,
\end{align}
%%
where $J^i_{t+\delta t}(X', \dots )$ are samples from some arbitrary jump process (e.g., compound Poisson) which could generally depend on a variety of inputs, including $X'$. 

\emph{Poisson process noises} would generally take the form
%%
\begin{align}
& X^i_{t+\delta t} = F^i_{t+\delta t}(X', t) + \textcolor{red}{N^i_{t+\delta t}({\lambda_i})-N^i_{t}({\lambda_i})}\,,
\end{align}
%%
where $N^i_{t}({\lambda_i})$ is a sample from a Poisson process with rate $\lambda_i$ for each of the state dimensions indexed by $i$. Note that we may also allow for correlations between the noises in different dimensions.

\emph{Time-inhomogeneous Poisson process noises} would generally take the form
%%
\begin{align}
& X^i_{t+\delta t} = F^i_{t+\delta t}(X', t) + \textcolor{red}{N^i_{t+\delta t}({\lambda^i_{t+\delta t}})-N^i_{t}({\lambda^i_t})}\,,
\end{align}
%%
where $\lambda^i_{t}$ is a deterministically-varying rate for each of the state dimensions indexed by $i$.

\emph{Cox (doubly-stochastic) process noises} would generally take the form
%%
\begin{align}
& X^i_{t+\delta t} = F^i_{t+\delta t}(X', t) + \textcolor{red}{N^i_{t+\delta t}({\Lambda^i_{t+\delta t}})-N^i_{t}({\Lambda^i_{t}})}\,,
\end{align}
%%
where the rate $\Lambda^i_{t}$ is now a sample from some continuous-time stochastic process (in the positive-only domain) for each of the state dimensions indexed by $i$.

\emph{Self-exciting process noises} would generally take the form
%%
\begin{align}
& X^i_{t+\delta t} = F^i_{t+\delta t}(X', t) + \textcolor{red}{N^i_{t+\delta t}[{\cal I}^i_{t+\delta t}(N', \dots)]-N^i_{t}[{\cal I}^i_{t}(N'', \dots)]}\,,
\end{align}
%%
where the stochastic rate ${\cal I}^i_{t}(N', \dots)$ now depends on the history of $N'$ explicitly (amongst other potential inputs - see, e.g., \href{https://en.wikipedia.org/wiki/Hawkes_process}{Hawkes processes}) for each of the state dimensions indexed by $i$.

\emph{Generalised probabilistic discrete state transitions} would take the form
%%
\begin{align}
& X^i_{t+\delta t} = \slash{F^i_{t+\delta t}(X', t)} + \textcolor{red}{T^i_{t+\delta t}(X')}\,,
\end{align}
%%
where $T^i_{t+\delta t}(X')$ is a generator of the next state to occupy. This generator uses the current state transition probabilities (which are generally conditional on $X'$) at each new step.

\section{\sffamily Summary of desirable features}

\begin{itemize}
\item{using the learnings from the previous sections looking at specific example processes}
\item{above formalism is so general that it can do anything - so while it shall serve as a useful guide and reference point, it would be good here to go through more of the specific desirable components we want to have access to in the software itself}
\item{it might not always be convenient to have the windowed histories stored as S but some other varying quantity which can be used to construct S? take fractional brownian motion as an example of this! hence, need to provide more possible input histories into S}
\item{want the timestep to have either exponentially-sampled lengths or fixed lengths in time}
\item{formalism already isn't explicit about the choice of deterministic integrator in time}
\item{but also want to be able to choose the stochastic integrator in continuous processes (Itô or Stratonovich?)}
\item{enable correlated noise terms at the sample generator level}
\item{configurable setup of simulations with just yamls + a single .go file defining the terms}
\end{itemize}


Test cite~\cite{Dimastrogiovanni:2018xnn}

\section{\sffamily Software design choices}

Ideally, the stochadex sampler should be designed to try and maintain a balance between performance and flexibility of utilisation.


\chapter{\sffamily Simulating a financial market}

{\bfseries\sffamily Concept.} The idea here is to use the Q-Hawkes processes and the Bouchaud work to come up with some interesting simulations of financial markets. 

\section{\sffamily Introducing Q-Hawkes processes}


\chapter{\sffamily Quantum jumps on generic networks}

{\bfseries\sffamily Concept.} The idea is to follow this sort of thing \href{https://en.wikipedia.org/wiki/Quantum_jump_method}{here} to simulate the Lindblad equation over an arbitrary network of entangled states.

\section{\sffamily The Lindblad equation}


\part*{{\sffamily {\color{gray75} Part 2.} How do we then learn/identify the answer to Part 1 from real-world data?}}


\chapter{\sffamily Inferring dynamical 2D maps}

{\bfseries\sffamily Concept.} The idea here is 


\section{\sffamily Adapting the stochadex formalism}

\chapter{\sffamily Learning from ants on curved surfaces}

{\bfseries\sffamily Concept.} The idea here is 

\section{\sffamily Diffusive limits for ant interactions}


\chapter{\sffamily Hydrodynamic ensembles from input data}

{\bfseries\sffamily Concept.} The idea here is 


\section{\sffamily The Boltzmann/Navier-Stokes equations}

\chapter{\sffamily Generalised statistical inference tools}

{\bfseries\sffamily Concept.} The idea here is to extend the stochadex with tools for very generalised statistical inference (ABC algorithms and the like) that will work in nearly every situation. Probably need to exploit the phase space analogy of the formalism.

\section{\sffamily Likelihood-free methods}


\part*{{\sffamily {\color{gray75} Part 3.} How do we simulate a general set of control policies to interact with the answer to Part 1?}}


\chapter{\sffamily Interacting with systems in general}

{\bfseries\sffamily Concept.} The idea here is 

\section{\sffamily Parameterising general interactions}


\chapter{\sffamily Managing a Rugby match}

{\bfseries\sffamily Concept.} The idea here is 

\section{\sffamily Introduction}

Since the basic game engine will run using the \href{https://github.com/umbralcalc/stochadex}{stochadex} sampler, the novelties in this project are all in the design of the rugby match model itself. And, in this instance, I'm not especially keen on spending a lot of time doing detailed data analysis to come up with the most realistic values for the parameters that are dreamed up here. Even though this would also be interesting.

One could do this data analysis, for instance, by scraping player-level performance data from one of the excellent websites that collect live commentary data such as \href{https://www.rugbypass.com/}{rugbypass.com} or \href{https://www.espn.co.uk/rugby/}{espn.co.uk/rugby}.

This game is primarily a way of testing out the interface of the stochadex for other users to build projects with. This should help to both iron out some of the kinks in the design, as well as prioritise adding some more convenience methods for event-based modelling into its code base.

\section{\sffamily Designing the event simulation engine}

We need to begin by specifying an appropriate event space to live in when simulating a rugby match. It is important at this level that events are defined in quite broadly applicable terms, as it will define the state space available to our stochastic sampler and hence the simulated game will never be allowed to exist outside of it. So, in order to capture the fully detailed range of events that are possible in a real-world match, we will need to be a little imaginative in how we define certain gameplay elements when we move through the space.

The diagrams below sum up what should hopefully work as a decent initial approximation while providing a little context with specific examples of play action.

\begin{figure}[h]
\includegraphics[width=8cm]{images/trywizard-event-graph.png}
\caption{Simplified event graph of a rugby union match.}
\label{fig:event-graph}
\end{figure}

\begin{figure}[h]
\includegraphics[width=10cm]{images/trywizard-model-ideas-sketch.png}
\caption{Optional model ideas.}
\label{fig:model-ideas}
\end{figure}

\section{\sffamily Linking to player attributes}

\section{\sffamily Deciding on gameplay actions}

\section{\sffamily Writing the game itself}

\chapter{\sffamily Influencing house prices}

{\bfseries\sffamily Concept.} The idea here is 


\part*{{\sffamily {\color{gray75} Part 4.} How do we then optimise the answer to Part 3 to achieve a specified control objective?}}


\chapter{\sffamily Optimising actions for control objectives}

{\bfseries\sffamily Concept.} The idea  controlhere is 


\chapter{\sffamily Resource allocation for epidemics}

{\bfseries\sffamily Concept.} The idea here is to limit the spread of some abstract epidemic through the correct time-dependent resource allocation.


\chapter{\sffamily Quantum system control}

{\bfseries\sffamily Concept.} The idea here is to follow stuff along these lines \href{https://arxiv.org/pdf/1210.7127.pdf}{here}.


\chapter{\sffamily Other models}

{\bfseries\sffamily Concept.} The idea here is




%\appendix
%\chapter{First and only appendix}
\backmatter
\bibliographystyle{JHEP}
\bibliography{book}
\end{document}