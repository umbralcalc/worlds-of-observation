<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Robert J. Hardwick" />
  <title>Diffusing Ideas</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6" type="text/javascript"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="style.css">
</head>
<body>

<!-- Navbar -->
<div class="w3-top">
  <div class="w3-bar w3-light-grey w3-card w3-left-align w3-large">
    <a class="w3-bar-item w3-button w3-hide-medium w3-hide-large w3-right w3-padding-large w3-hover-white w3-large w3-light-grey" href="javascript:void(0);" onclick="myFunction()" title="Toggle Navigation Menu"><i class="fa fa-bars"></i></a>
    <a href="#" class="w3-bar-item w3-button w3-padding-large w3-white">Home</a>
    <a href="#" class="w3-bar-item w3-button w3-hide-small w3-padding-large w3-hover-white">Link 1</a>
    <a href="#" class="w3-bar-item w3-button w3-hide-small w3-padding-large w3-hover-white">Link 2</a>
    <a href="#" class="w3-bar-item w3-button w3-hide-small w3-padding-large w3-hover-white">Link 3</a>
    <a href="#" class="w3-bar-item w3-button w3-hide-small w3-padding-large w3-hover-white">Link 4</a>
  </div>

  <!-- Navbar on small screens -->
  <div id="navDemo" class="w3-bar-block w3-white w3-hide w3-hide-large w3-hide-medium w3-large">
    <a href="#" class="w3-bar-item w3-button w3-padding-large">Link 1</a>
    <a href="#" class="w3-bar-item w3-button w3-padding-large">Link 2</a>
    <a href="#" class="w3-bar-item w3-button w3-padding-large">Link 3</a>
    <a href="#" class="w3-bar-item w3-button w3-padding-large">Link 4</a>
  </div>
</div>

<header class="w3-container w3-light-grey w3-center" style="padding:128px 16px">
<h1 class="title">Diffusing Ideas</h1>
<h3 class="subtitle">Software, noise and building mathematical toys</h3>
<p class="author"><strong>Robert J. Hardwick</strong></p>
</header>
<h2 class="unnumbered" id="introduction">Introduction</h2>
<p><em>Diffusing Ideas</em> is a book of research exploration and software development which I have written for the interest of mathematically-inclined programmers and computational scientists. It’s the output of many interrelated projects over several years which have sought to generalise the computational mathematics of simulating, statistically inferring, manipulating and automatically controlling stochastic phenomena as far as possible.</p>
<p>The book accompanies a lot of new open-source scientific software written predominantly in Go <span class="citation" data-cites="golang">[1]</span>, with a little Python <span class="citation" data-cites="pythonlang">[2]</span> to top it off. A major motivation for creating these new tools is to prepare a foundation of code from which to develop new and more complex applications. I also hope that the resulting framework will enable anyone to explore and study new phenomena effectively, regardless of their scientific background.</p>
<p>The need to properly test all this software has also provided a wonderful excuse to study and play with an extensive range of mathematical toy models. I’ve chosen these models based on a fairly broad background of interests, but also to illustrate the remarkable cross-disciplinary applicability of stochastic processes. However, I’ve often found that mathematical formalities can obscure the computations that a programmer must implement. So, while I’ve tried to be as ambitious as possible with the level of technical sophistication in these models, I’ve also tried to write the expressions in a computer-friendly way where feasible.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>A quick note on the code: any software that I describe in this book (including the software which compiles the book itself <span class="citation" data-cites="diffusingideasbookgithub">[3]</span>) will always be shared under a MIT License <span class="citation" data-cites="mitlicense">[4]</span> in a public Git repository.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> Forking these repositories and submitting pull requests for new features or applications is strongly encouraged too, though I apologise in advance if I don’t follow these up very quickly as all of this work has to be conducted independently in free time, outside of work hours.</p>
<p>No quest would be complete without a guide, so I think this introduction should end with a list of the key milestones in the book; comprising its four major parts. These parts each correspond to answering one of the following interdependent research questions:</p>
<ol>
<li><p><span>How do we simulate a general set of stochastic phenomena?</span></p></li>
<li><p><span>How do we then learn/identify the answer to <span><strong>Part 1</strong></span> from real-world data?</span></p></li>
<li><p><span>How do we simulate a general set of control policies to interact with the answer to <span><strong>Part 1</strong></span>?</span></p></li>
<li><p><span>How do we then optimise the answer to <span><strong>Part 3</strong></span> to achieve a specified control objective?</span></p></li>
</ol>
<h2 class="unnumbered" id="table-of-contents">Table of contents</h2>
<h1 id="how-do-we-simulate-a-general-set-of-stochastic-phenomena"> How do we simulate a general set of stochastic phenomena?</h1>
<h2 id="building-a-generalised-simulator">Building a generalised simulator</h2>
<p><span><strong>Concept.</strong></span> To design and build a generalised simulation engine that is able to generate samples from a ‘Pokédex’ of possible stochastic processes that a researcher might encounter. A ‘Pokédex’ here is just my fanciful description for a very general class of multidimensional stochastic processes that pop up everywhere in taming the mathematical wilds of real-world phenomena, and which also leads to a name for the software itself: the ‘stochadex’. With such a thing pre-built and self-contained, it can become the basis upon which to build generalised software solutions for a lot of different problems. For the mathematically-inclined, this chapter will require the introduction of a new formalism which we shall refer back to throughout the book. For the programmers, the public Git repository for the code that is described in this chapter can be found here: <a href="https://github.com/umbralcalc/stochadex">https://github.com/umbralcalc/stochadex</a>.</p>
<h3 id="computational-formalism">Computational formalism</h3>
<p>Before we dive into software design of the stochadex, we need to mathematically define the general computational approach that we’re going to take. Because the language of stochastic processes is primarily mathematics, I’d argue this step is essential in enabling a really general description. From experience, it seems reasonable to start by writing down the following formula which describes iterating some arbitrary process forward in time (by one finite step) and adding a new row each to some matrix <span class="math inline">\(X&#39; \rightarrow X\)</span> <span class="math display">\[\begin{aligned}
X^{i}_{{\sf t}+1} &amp;= F^{i}_{{\sf t}+1}(X&#39;,{\sf t}) \,, \label{eq:x-step-def}\end{aligned}\]</span> where: <span class="math inline">\(i\)</span> is an index for the dimensions of the ‘state’ space; <span class="math inline">\({\sf t}\)</span> is the current time index for either a discrete-time process or some discrete approximation to a continuous-time process; <span class="math inline">\(X\)</span> is the next version of <span class="math inline">\(X&#39;\)</span> after one timestep (and hence one new row has been added); and <span class="math inline">\(F^i_{{\sf t}+1}(X&#39;,{\sf t})\)</span> as the latest element of an arbitrary matrix-valued function. As we shall discuss shortly, <span class="math inline">\(F^i_{{\sf t}+1}(X&#39;,{\sf t})\)</span> may represent not just operations on deterministic variables, but also on stochastic ones. There is also no requirement for the function to be continuous.</p>
<figure>
<img src="images/fundamental-loop.drawio.png" id="fig:fundamental-loop" style="width:10cm" alt="" /><figcaption>Graph representation of Eq. (<a href="#eq:x-step-def" data-reference-type="ref" data-reference="eq:x-step-def">[eq:x-step-def]</a>).</figcaption>
</figure>
<p>The basic computational idea here is illustrated in Fig. <a href="#fig:fundamental-loop" data-reference-type="ref" data-reference="fig:fundamental-loop">1.1</a>; we iterate the matrix <span class="math inline">\(X\)</span> forward in time by a row, and use its previous version <span class="math inline">\(X&#39;\)</span> as an entire matrix input into a function which populates the elements of its latest rows. Pretty simple! But why go to all this trouble of storing matrix inputs for previous values of the same process? It’s true that this is mostly redundant for <em>Markovian</em> phenomena, i.e., processes where their only memory of their history is the most recent value they took. However, for a large class of stochastic processes a full memory<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> of past values is essential to consistently construct the sample paths moving forward. This is true in particular for <em>non-Markovian</em> phenomena, where the latest values don’t just depend on the immediately previous ones but can depend on values which occured much earlier in the process as well.</p>
<p>For more complex physical models and integrators, the distinct notions of ‘numerical timestep’ and ‘total elapsed continuous time’ will crop up quite frequently. Hence, before moving on further details, it will be important to define the total elapsed time variable <span class="math inline">\(t({\sf t})\)</span> for processes which are defined in continuous time. Assuming that we have already defined some function <span class="math inline">\(\delta t({\sf t})\)</span> which returns the specific change in continuous time that corresponds to the step <span class="math inline">\({\sf t}-1 \rightarrow {\sf t}\)</span>, we will always be able to compute the total elapsed time through the relation <span class="math display">\[\begin{aligned}
t({\sf t}) &amp;= \sum^{{\sf t}}_{{\sf t}&#39;=0}\delta t({\sf t}&#39;) \label{eq:t-steps-sum} \,.\end{aligned}\]</span> This seems a lot of effort, no? Well it’s important to remember that our steps in continuous time may not be constant, so by defining the <span class="math inline">\(\delta t({\sf t})\)</span> function and summing over it we can enable this flexibility in the computation.</p>
<p>So, now that we’ve mathematically defined a really general notion of iterating the stochastic process forward in time, it makes sense to discuss some simple examples. For instance, it is frequently possible to split <span class="math inline">\(F\)</span> up into deteministic (denoted <span class="math inline">\(D\)</span>) and stochastic (denoted <span class="math inline">\(S\)</span>) matrix-valued functions like so <span class="math display">\[\begin{aligned}
&amp; F^{i}_{{\sf t}+1}(X&#39;,{\sf t}) = D^{i}_{{\sf t}+1}(X&#39;,{\sf t}) + S^{i}_{{\sf t}+1}(X&#39;,{\sf t}) \,.\end{aligned}\]</span> In the case of stochastic processes with continuous sample paths, it’s also nearly always the case with mathematical models of real-world systems that the deterministic part will at least contain the term <span class="math inline">\(D^{i}_{{\sf t}+1}(X&#39;,{\sf t}) = X^i_{\sf t}\)</span> because the overall system is described by some stochastic differential equation. This is not a really requirement in our general formalism, however.</p>
<p>What about the stochastic term? For example, if we wanted to consider a <em>Wiener process noise</em>, we can define <span class="math inline">\(W^i_{{\sf t}}\)</span> is a sample from a Wiener process for each of the state dimensions indexed by <span class="math inline">\(i\)</span> and our formalism becomes <span class="math display">\[\begin{aligned}
&amp; S^{i}_{{\sf t}+1}(X&#39;,{\sf t}) = W^i_{{\sf t}+1}-W^i_{\sf t} \label{eq:wiener}\,.\end{aligned}\]</span> One draws the increments <span class="math inline">\(W^i_{{\sf t}+1}-W^i_{\sf t}\)</span> from a normal distribution with a mean of <span class="math inline">\(0\)</span> and a variance equal to the length of continuous time that the step corresponded to <span class="math inline">\(\delta t({\sf t}+1)\)</span>, i.e., the probability density <span class="math inline">\(P^i_{{\sf t}+1}(x)\)</span> of the increments <span class="math inline">\(x^i=W^i_{{\sf t}+1}-W^i_{\sf t}\)</span> is <span class="math display">\[\begin{aligned}
P^i_{{\sf t}+1}(x) &amp;= {\sf NormalPDF}[x^i;0,\delta t({\sf t}+1)] \,.\end{aligned}\]</span> Note that for state spaces with dimensions <span class="math inline">\(&gt;1\)</span>, we could also allow for non-trivial cross-correlations between the noises in each dimension.</p>
<p>In another example, to model <em>geometric Brownian motion noise</em> we would simply have to multiply <span class="math inline">\(X^i_{\sf t}\)</span> to the Wiener process like so <span class="math display">\[\begin{aligned}
&amp; S^{i}_{{\sf t}+1}(X&#39;,{\sf t}) = X^i_{\sf t}(W^i_{{\sf t}+1}-W^i_{\sf t})\label{eq:gbm} \,.\end{aligned}\]</span> Here we have implicitly adopted the Itô interpretation to describe this stochastic integration. Given a carefully-defined integration scheme other interpretations of the noise would also be possible with our formalism too, e.g., Stratonovich<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> or others within the more general ‘<span class="math inline">\(\alpha\)</span>-family’ <span class="citation" data-cites="van1992stochastic risken1996fokker rog-will-2000">[5]–[7]</span>.</p>
<p>We can imagine even more general processes that are still Markovian. One example of these in a single-dimension state space would be <span class="math display">\[\begin{aligned}
S^0_{{\sf t}+1}(X&#39;,{\sf t}) &amp;= g[W^0_{{\sf t}+1},t({\sf t}+1)]-g[W^0_{\sf t}, t({\sf t})] \\
&amp;= \bigg[ \frac{\partial g}{\partial t} + \frac{1}{2}\frac{\partial^2 g}{\partial x^2} \bigg] \delta t ({\sf t}+1) + \frac{\partial g}{\partial x} (W^0_{{\sf t}+1}-W^0_{\sf t}) \label{eq:general-wiener}\,,\end{aligned}\]</span> where <span class="math inline">\(g(x,t)\)</span> is some continuous function of its arguments which has been expanded out with Itô’s Lemma on the second line. Note also that the computations in Eq. (<a href="#eq:general-wiener" data-reference-type="ref" data-reference="eq:general-wiener">[eq:general-wiener]</a>) could be performed with numerical derivatives in principle if the function were extremely complicated.</p>
<p>Let’s now look at a more complicated type of noise. For example, <em>fractional Brownian motion</em> <span class="math inline">\([B_{H}]_{\sf t}\)</span> with Hurst exponent <span class="math inline">\(H\)</span>. Following Ref. <span class="citation" data-cites="decreusefond1999stochastic">[8]</span>, we can simulate this process in one of our state space dimensions by modifying a standard Wiener process like so <span class="math display">\[\begin{aligned}
S^{0}_{{\sf t}+1}(X&#39;,{\sf t}) &amp;= \frac{(W^0_{{\sf t}+1} - W^0_{\sf t})}{\delta t({\sf t}+1)}\int^{t({\sf t}+1)}_{t({\sf t})}{\rm d}t&#39; \frac{(t&#39;-t)^{H-\frac{1}{2}}}{\Gamma (H+\frac{1}{2})} {}_2F_1 \bigg( H-\frac{1}{2};\frac{1}{2}-H;H+\frac{1}{2};1-\frac{t&#39;}{t}\bigg) \label{eq:fbm} \,,\end{aligned}\]</span> where <span class="math inline">\(S^{0}_{{\sf t}+1}(X&#39;,{\sf t})=[B_{H}]_{{\sf t}+1}-[B_{H}]_{{\sf t}}\)</span>. The integral in Eq. (<a href="#eq:fbm" data-reference-type="ref" data-reference="eq:fbm">[eq:fbm]</a>) can be approximated using an appropriate numerical procedure (like the trapezium rule). In the expression above <span class="math inline">\({}_2F_1\)</span> and <span class="math inline">\(\Gamma\)</span> are the ordinary hypergeometric and gamma functions, respectively.</p>
<p>So far we have mostly been discussing noises with continuous sample paths, but we can easily adapt our computation to discontinuous sample paths as well. For instance, <em>Poisson process noises</em> would generally take the form <span class="math display">\[\begin{aligned}
S^{i}_{{\sf t}+1}(X&#39;,{\sf t}) &amp;= [N_{\lambda}]^i_{{\sf t}+1}-[N_{\lambda}]^i_{\sf t}\,,\end{aligned}\]</span> where <span class="math inline">\([N_{\lambda}]^i_{\sf t}\)</span> is a sample from a Poisson process with rate <span class="math inline">\(\lambda\)</span>. One can think of this process as counting the number of events which have occured up to the given interval of time, where the intervals between each succesive event are exponentially distributed with mean <span class="math inline">\(1/\lambda\)</span>. Such a simple counting process could be simulated exactly by explicitly setting a newly-drawn exponential variate to the next continuous time jump <span class="math inline">\({\delta t}({\sf t}+1)\)</span> and iterating the counter. Other exact methods exist to handle more complicated processes involving more than one type of ‘event’, such as the Gillespie algorithm <span class="citation" data-cites="gillespie1977exact">[9]</span> — though these techniques are not always be applicable in every situation.</p>
<p>Is using step size variation always possible? If we consider a <em>time-inhomogeneous Poisson process noise</em>, which would generally take the form <span class="math display">\[\begin{aligned}
S^{i}_{{\sf t}+1}(X&#39;,{\sf t}) &amp;= [N_{\lambda ({\sf t}+1)}]^i_{{\sf t}+1}-[N_{\lambda ({\sf t})}]^i_{\sf t}\,,\end{aligned}\]</span> the rate <span class="math inline">\(\lambda ({\sf t})\)</span> has become a deterministically-varying function in time. In this instance, it likely not be accurate to simulate this process by drawing exponential intervals with a mean of <span class="math inline">\(1/\lambda ({\sf t})\)</span> because this mean could have changed by the end of the interval which was drawn. An alternative approach (which is more generally capable of simulating jump processes but is an approximation) first uses a small time interval <span class="math inline">\(\tau\)</span> such that the most likely thing to happen in this period is nothing, and then the probability of the event occuring is simply given by <span class="math display">\[\begin{aligned}
p({\sf event}) &amp;= \frac{\lambda ({\sf t})}{\lambda ({\sf t}) + \frac{1}{\tau}} \label{eq:rejection}\,.\end{aligned}\]</span> This idea can be applied to phenomena with an arbitrary number of events and works well as a generalised approach to event-based simulation, though its main limitation is worth remembering; in order to make the approximation good, <span class="math inline">\(\tau\)</span> often must be quite small and hence our simulator must churn through a lot of steps. From now on we’ll refer to this well-known technique as the <em>rejection method</em>.</p>
<p>There are a few extensions to the simple Poisson process that introduce additional stochastic processes. <em>Cox (doubly-stochastic) processes</em>, for instance, are basically where we replace the time-dependent rate <span class="math inline">\(\lambda ({\sf t})\)</span> with independent samples from some other stochastic process <span class="math inline">\(\Lambda ({\sf t})\)</span>. For example, a Neyman-Scott process <span class="citation" data-cites="neyman1958statistical">[10]</span> can be mapped as a special case of this because it uses a Poisson process on top of another Poisson process to create maps of spatially-distributed points. In our formalism, a two-state implementation of the Cox process noise would look like <span class="math display">\[\begin{aligned}
S^{0}_{{\sf t}+1}(X&#39;,{\sf t}) &amp;= \Lambda ({\sf t}+1) \\
S^{1}_{{\sf t}+1}(X&#39;,{\sf t}) &amp;= [N_{S^{0}_{{\sf t}+1}}]^i_{{\sf t}+1}-[N_{S^{0}_{{\sf t}}}]^i_{\sf t}\,.\end{aligned}\]</span> Another extension is <em>compound Poisson process noise</em>, where it’s the count values <span class="math inline">\([N_{\lambda}]^i_{\sf t}\)</span> which are replaced by independent samples <span class="math inline">\([J_{\lambda}]^i_{\sf t}\)</span> from another probability distribution, i.e., <span class="math display">\[\begin{aligned}
S^{i}_{{\sf t}+1}(X&#39;,{\sf t}) &amp;= [J_{\lambda}]^i_{{\sf t}+1}-[J_{\lambda}]^i_{\sf t}\,.\end{aligned}\]</span> Note that the rejection method of Eq. (<a href="#eq:rejection" data-reference-type="ref" data-reference="eq:rejection">[eq:rejection]</a>) can be employed effectively to simulate any of these extensions as long as a sufficiently small <span class="math inline">\(\tau\)</span> is chosen.</p>
<p>All of the examples we have discussed so far are Markovian. Given that we have explicitly constructed the formalism to handle non-Markovian phenomena as well, it would be worthwhile going some examples of this kind of process too. <em>Self-exciting process noises</em> would generally take the form <span class="math display">\[\begin{aligned}
S^{0}_{{\sf t}+1}(X&#39;,{\sf t}) &amp;= {\cal I}_{{\sf t}+1} (X&#39;,{\sf t}) \\
S^{1}_{{\sf t}+1}(X&#39;,{\sf t}) &amp;= [N_{S^{0}_{{\sf t}+1}}]^i_{{\sf t}+1}-[N_{S^{0}_{{\sf t}}}]^i_{\sf t} \,,\end{aligned}\]</span> where the stochastic rate <span class="math inline">\({\cal I}_{{\sf t}+1} (X&#39;,{\sf t})\)</span> now depends on the history explicitly. Amongst other potential inputs we can see, e.g., Hawkes processes <span class="citation" data-cites="hawkes1971spectra">[11]</span> as an example of above by substituting <span class="math display">\[\begin{aligned}
{\cal I}_{{\sf t}+1} (X&#39;,{\sf t}) &amp;= \mu + \sum^{{\sf t}}_{{\sf t}&#39;=0}\gamma [t({\sf t})-t({\sf t}&#39;)](S^{1}_{{\sf t}&#39;}-S^{1}_{{\sf t}&#39;-1}) \,,\end{aligned}\]</span> where <span class="math inline">\(\gamma\)</span> is the ‘exciting kernel’ and <span class="math inline">\(\mu\)</span> is some constant background rate.</p>
<p>Note that this idea of integration kernels could also be applied back to our Wiener process. For example, another type of non-Markovian phenomenon that frequently arises across physical and life systems integrates the Wiener process history like so <span class="math display">\[\begin{aligned}
S^{0}_{{\sf t}+1}(X&#39;,{\sf t}) &amp;= W^0_{{\sf t}+1}-W^0_{\sf t}\\
S^{1}_{{\sf t}+1}(X&#39;,{\sf t}) &amp;= \frac{1}{T}\sum^{{\sf t}}_{{\sf t}&#39;=0}e^{-\frac{t({\sf t})-t({\sf t}&#39;)}{T}} (S^{0}_{{\sf t}&#39;}-S^{0}_{{\sf t}&#39;-1}) \,,\end{aligned}\]</span> where <span class="math inline">\(T\)</span> is some decay coefficient which quantifies the length of memory in continuous time.</p>
<p>So we’ve introduced the basic elements of our computational formalism and demonstrated how flexible the approach can be in simulating just about any stochastic phenomenon imaginable. Before progressing to algorithm design, it will be helpful to discuss some useful concepts that should enable us analyse the system later on in the book.</p>
<h3 id="useful-probabilistic-concepts">Useful probabilistic concepts</h3>
<p>The general stochastic process that we defined with Eq. (<a href="#eq:x-step-def" data-reference-type="ref" data-reference="eq:x-step-def">[eq:x-step-def]</a>) also has an implicit <em>master equation</em> associated to it which fully describes the time evolution of the <em>probability density function</em> <span class="math inline">\(P_{{\sf t}+1}(x)\)</span> of the most recent matrix row <span class="math inline">\(x=X_{{\sf t}+1}\)</span> at time <span class="math inline">\({\sf t}\)</span>. This can be written as <span class="math display">\[\begin{aligned}
P_{{\sf t}+1}(x) &amp;= \frac{1}{{\sf t}}\sum_{{\sf t}&#39;=0}^{{\sf t}}\int_{\omega_{{\sf t}&#39;}}{\rm d}x&#39; P_{{\sf t}&#39;}(x&#39;) P_{({\sf t}+1){\sf t}&#39;}(x\vert x&#39;) \label{eq:master-x-cont} \,,\end{aligned}\]</span> where at the moment we are assuming the state space is continuous in each dimension and <span class="math inline">\(P_{({\sf t}+1){\sf t}&#39;}(x\vert x&#39;)\)</span> is the conditional probability that the matrix row at time <span class="math inline">\(({\sf t}+1)\)</span> will be <span class="math inline">\(x=X_{{\sf t}+1}\)</span> given that the row at time <span class="math inline">\({\sf t}&#39;\)</span> was <span class="math inline">\(x&#39;=X_{{\sf t}&#39;}\)</span>. This is a very general equation which should almost always apply to any continuous stochastic phenomenon we want to study in due course. To try an understand what this equation is saying, I find it’s helpful to think of an iterative relationship between probabilities, which are connected by their relative conditional probabilities. This kind of thinking is also illustrated in Fig. <a href="#fig:master-eqn" data-reference-type="ref" data-reference="fig:master-eqn">1.2</a>.</p>
<p>The factor of <span class="math inline">\(1/{\sf t}\)</span> in Eq. (<a href="#eq:master-x-cont" data-reference-type="ref" data-reference="eq:master-x-cont">[eq:master-x-cont]</a>) is a normalisation factor — this just normalises the sum of all probabilities to 1 given that there is a sum over <span class="math inline">\({\sf t}&#39;\)</span>. Note that, if the process is defined over continuous time, we would need to replace <span class="math display">\[\begin{aligned}
\frac{1}{{\sf t}}\sum_{{\sf t}&#39;=0}^{{\sf t}} \rightarrow \frac{1}{t({\sf t})}\sum_{{\sf t}&#39;=0}^{{\sf t}}\delta t({\sf t}&#39;) \,.\end{aligned}\]</span> But what is <span class="math inline">\(\omega_{\sf t}\)</span>? You can think of this as just the domain of possible <span class="math inline">\(x&#39;\)</span> inputs into the integral which will depend on the specific stochastic process we are looking at.</p>
<figure>
<img src="images/master-eq-graph.drawio.png" id="fig:master-eqn" style="width:8cm" alt="" /><figcaption>Graph representation of Eq. (<a href="#eq:master-x-cont" data-reference-type="ref" data-reference="eq:master-x-cont">[eq:master-x-cont]</a>).</figcaption>
</figure>
<p>What if we wanted the joint distribution of both rows <span class="math inline">\(P_{({\sf t}+1){\sf t}&#39;}(x,x&#39;)\)</span>? One way to obtain this would be to extend Eq. (<a href="#eq:master-x-cont" data-reference-type="ref" data-reference="eq:master-x-cont">[eq:master-x-cont]</a>) such that both matrix rows are marginalised over separately like so <span class="math display">\[\begin{aligned}
&amp;P_{({\sf t}+1){\sf t}&#39;}(x,x&#39;) = \nonumber \\
&amp;\qquad \frac{1}{({\sf t}&#39;-1){\sf t}}\sum_{{\sf t}&#39;&#39;=0}^{{\sf t}}\sum_{{\sf t}&#39;&#39;&#39;=0}^{{\sf t}&#39;-1}\int_{\omega_{{\sf t}&#39;&#39;}}{\rm d}x&#39;&#39;\int_{\omega_{{\sf t}&#39;&#39;&#39;}}{\rm d}x&#39;&#39;&#39; P_{{\sf t}&#39;&#39;{\sf t}&#39;&#39;&#39;}(x&#39;&#39;, x&#39;&#39;&#39;) P_{({\sf t}+1){\sf t}&#39;&#39;}(x\vert x&#39;&#39;)P_{{\sf t}&#39;{\sf t}&#39;&#39;&#39;}(x&#39;\vert x&#39;&#39;&#39;) \label{eq:joint-master-x-cont} \,.\end{aligned}\]</span> Given Eqs. (<a href="#eq:master-x-cont" data-reference-type="ref" data-reference="eq:master-x-cont">[eq:master-x-cont]</a>) and (<a href="#eq:joint-master-x-cont" data-reference-type="ref" data-reference="eq:joint-master-x-cont">[eq:joint-master-x-cont]</a>) it’s also possible to work out what the conditional probabilities would look like using the simple relation <span class="math display">\[\begin{aligned}
P_{({\sf t}+1){\sf t}&#39;}(x\vert x&#39;) &amp;= \frac{P_{({\sf t}+1){\sf t}&#39;}(x,x&#39;)}{P_{{\sf t}&#39;}(x&#39;)} \label{eq:cond-master-x-cont} \,.\end{aligned}\]</span></p>
<p>The implicit notation in Eq. (<a href="#eq:master-x-cont" data-reference-type="ref" data-reference="eq:master-x-cont">[eq:master-x-cont]</a>) can hide some staggering complexity. To analyse the system in more detail, we can also do a kind of Kramers-Moyal expansion <span class="citation" data-cites="kramers1940brownian moyal1949stochastic">[12], [13]</span> for each point in time to approximate the overall equation like this <span class="math display">\[\begin{aligned}
P_{{\sf t}+1}(x) &amp;= \frac{1}{{\sf t}}\sum_{{\sf t}&#39;=0}^{{\sf t}}P_{{\sf t}&#39;}(x) - \frac{1}{{\sf t}}\sum_{{\sf t}&#39;=0}^{{\sf t}}\sum_{i=1}^d\frac{\partial}{\partial x^i}\big[ \alpha^i_{({\sf t}+1){\sf t}&#39;}(x)P_{{\sf t}&#39;}(x)\big] \nonumber \\
&amp; \qquad + \frac{1}{2{\sf t}}\sum_{{\sf t}&#39;=0}^{{\sf t}}\sum_{i=1}^d\sum_{j=1}^d\frac{\partial}{\partial x^i}\frac{\partial}{\partial x^j}\big[ \beta^{ij}_{({\sf t}+1){\sf t}&#39;}(x)P_{{\sf t}&#39;}(x)\big] + \dots \label{eq:master-x-cont-kramers-moyal} \,,\end{aligned}\]</span> in which we have assumed that the state space is <span class="math inline">\(d\)</span>-dimensional. In this expansion, we also needed to define these new integrals <span class="math display">\[\begin{aligned}
\alpha^i_{({\sf t}+1){\sf t}&#39;}(x) &amp;=\int_{\omega_{{\sf t}&#39;}} {\rm d}x&#39;(x&#39;-x)^iP_{({\sf t}+1){\sf t}&#39;}(x&#39;\vert x) \\
\beta^{ij}_{({\sf t}+1){\sf t}&#39;}(x) &amp;= \int_{\omega_{{\sf t}&#39;}} {\rm d}x&#39;(x&#39;-x)^i(x&#39;-x)^jP_{({\sf t}+1){\sf t}&#39;}(x&#39;\vert x) \,.\end{aligned}\]</span> So the matrix notation of Eq. (<a href="#eq:master-x-cont" data-reference-type="ref" data-reference="eq:master-x-cont">[eq:master-x-cont]</a>) can indeed hide a very complicated calculation. Truncating the expansion at second-order, Eq. (<a href="#eq:master-x-cont-kramers-moyal" data-reference-type="ref" data-reference="eq:master-x-cont-kramers-moyal">[eq:master-x-cont-kramers-moyal]</a>) tells us that there can be first and second derivatives contributing to the flow of probability to each element of the row <span class="math inline">\(x=X_{{\sf t}+1}\)</span> which depend on every element of the matrix <span class="math inline">\(X&#39;\)</span>. The probability does indeed <em>flow</em>, in fact. We can define a quantity known as the ‘probability current’ <span class="math inline">\(J_{({\sf t}+1){\sf t}&#39;}(x)\)</span> from <span class="math inline">\({\sf t}&#39;\)</span> to <span class="math inline">\(({\sf t}+1)\)</span> which illustrates this through the following continuity relation <span class="math display">\[\begin{aligned}
P_{{\sf t}+1}(x) - \frac{1}{{\sf t}}\sum_{{\sf t}&#39;=0}^{{\sf t}}P_{{\sf t}&#39;}(x) = \frac{1}{{\sf t}}\sum_{{\sf t}&#39;=0}^{{\sf t}}\big[ P_{{\sf t}+1}(x) - P_{{\sf t}&#39;}(x)\big] = - \frac{1}{{\sf t}}\sum_{{\sf t}&#39;=0}^{{\sf t}}J_{({\sf t}+1){\sf t}&#39;}(x) \,.\end{aligned}\]</span> By inspection of Eq. (<a href="#eq:master-x-cont-kramers-moyal" data-reference-type="ref" data-reference="eq:master-x-cont-kramers-moyal">[eq:master-x-cont-kramers-moyal]</a>) we can therefore also deduce that <span class="math display">\[\begin{aligned}
J^i_{({\sf t}+1){\sf t}&#39;}(x) &amp;= \alpha^i_{({\sf t}+1){\sf t}&#39;}(x)P_{{\sf t}&#39;}(x) - \frac{1}{2}\sum_{j=1}^d\frac{\partial}{\partial x^j}\big[ \beta^{ij}_{({\sf t}+1){\sf t}&#39;}(x)P_{{\sf t}&#39;}(x)\big] + \dots \,.\end{aligned}\]</span></p>
<p>What would happen if we assumed that <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> were just arbitrary time-dependent functions? For example, let’s make the following assumptions <span class="math display">\[\begin{aligned}
\alpha^i_{({\sf t}+1){\sf t}&#39;}(x) &amp;= \mu^i({\sf t}&#39;)-x^i \\
\beta^{ij}_{({\sf t}+1){\sf t}&#39;}(x) &amp;= 2\Sigma^{ij}(\theta, {\sf t}&#39;) \,,\end{aligned}\]</span> where <span class="math inline">\(\mu ({\sf t}&#39;)\)</span> is an arbitrary vector-valued function of the timestep and <span class="math inline">\(\Sigma (\theta ,{\sf t}&#39;)\)</span> is an arbitrary matrix (often known as the ‘diffusion tensor’) which depends on both the timestep and a set of hyperparameters <span class="math inline">\(\theta\)</span>. If we now also assume stationarity of <span class="math inline">\(P_{{\sf t}&#39;}(x)=P_{{\sf t}&#39;&#39;}(x)\)</span> for any <span class="math inline">\({\sf t}&#39;\)</span> and <span class="math inline">\({\sf t}&#39;&#39;\)</span> such that <span class="math display">\[\begin{aligned}
P_{{\sf t}+1}(x) = \frac{1}{{\sf t}}\sum_{{\sf t}&#39;=0}^{{\sf t}} P_{{\sf t}&#39;}(x) \,,\end{aligned}\]</span> we can solve Eq. (<a href="#eq:master-x-cont-kramers-moyal" data-reference-type="ref" data-reference="eq:master-x-cont-kramers-moyal">[eq:master-x-cont-kramers-moyal]</a>) to obtain the following stationary solution <span class="math display">\[\begin{aligned}
P_{{\sf t}&#39;}(x) &amp;= {\sf MultivariateNormalPDF}[x;\mu ({\sf t}&#39;),\Sigma (\theta , {\sf t}&#39;)]\label{eq:stat-sol-kramers-moyal}\,.\end{aligned}\]</span> I actually hid a little bit of the detail in that last step; the solution also required the identification that the flow of probability between timesteps vanishes uniquely for each and every <span class="math inline">\({\sf t}&#39;\)</span> such that <span class="math inline">\(J_{({\sf t}+1){\sf t}&#39;}(x)=0\)</span>.</p>
<figure>
<img src="images/gp-like-diag.drawio.png" id="fig:stat-sol-kramers-moyal-cond" style="width:8cm" alt="" /><figcaption>Graph representation of the generative process implied by Eq. (<a href="#eq:stat-sol-kramers-moyal-cond" data-reference-type="ref" data-reference="eq:stat-sol-kramers-moyal-cond">[eq:stat-sol-kramers-moyal-cond]</a>).</figcaption>
</figure>
<p>It’s possible to take this derivation a bit further by expanding Eq. (<a href="#eq:joint-master-x-cont" data-reference-type="ref" data-reference="eq:joint-master-x-cont">[eq:joint-master-x-cont]</a>) in a similar fashion, truncating it to second-order, assuming only time-dependent terms and then solving it in the stationary limit. By plugging this solution (and its corresponding marginal distribution equivalent) into Eq. (<a href="#eq:cond-master-x-cont" data-reference-type="ref" data-reference="eq:cond-master-x-cont">[eq:cond-master-x-cont]</a>), it’s possible to get something that looks like this conditional distribution <span class="math display">\[\begin{aligned}
P_{({\sf t}+1){\sf t}&#39;}(x\vert x&#39;) &amp;\propto {\rm exp}\bigg\{ -\frac{1}{2}\sum^d_{i=1}\sum^d_{j=1}\big[ x-f({\sf t}+1)\big]^i [K^{-1}(\theta , {\sf t}+1,{\sf t}+1)]^{ij}\big[ x-f({\sf t}+1)\big]^j \nonumber \\
&amp; \qquad \qquad + \sum^d_{i=1}\sum^d_{j=1}\big[ x-f({\sf t}+1)\big]^i [K^{-1}(\theta , {\sf t}+1,{\sf t}&#39;)]^{ij}\big[ x&#39;-f({\sf t}&#39;)\big]^j  \bigg\} \label{eq:stat-sol-kramers-moyal-cond}\,,\end{aligned}\]</span> where <span class="math inline">\(K(\theta , {\sf t}+1,{\sf t}&#39;)\)</span> is some arbitrary covariance matrix that encodes how the correlation structure varies with the between compared states at two different timesteps and <span class="math inline">\(K^{-1}(\theta , {\sf t}+1,{\sf t}&#39;)\)</span> denotes taking its inverse. Eq. (<a href="#eq:stat-sol-kramers-moyal-cond" data-reference-type="ref" data-reference="eq:stat-sol-kramers-moyal-cond">[eq:stat-sol-kramers-moyal-cond]</a>) may look a bit familiar to some readers who like using Gaussian processes from the machine learning literature <span class="citation" data-cites="murphy2012machine">[14]</span> — this version implies a <em>generative</em> model for a future <span class="math inline">\(x\)</span> value (which I’ve illustrated in Fig <a href="#fig:stat-sol-kramers-moyal-cond" data-reference-type="ref" data-reference="fig:stat-sol-kramers-moyal-cond">1.3</a>), in contrast to the more standard equation used to <em>infer</em> values of <span class="math inline">\(f\)</span>. These are two sides of the same coin though.</p>
<p>What other processes can be described by Eq. (<a href="#eq:master-x-cont" data-reference-type="ref" data-reference="eq:master-x-cont">[eq:master-x-cont]</a>)? For Markovian phenomena, the equation no longer depends on timesteps older than the immediately previous one, hence the expression reduces to just <span class="math display">\[\begin{aligned}
P_{{\sf t}+1}(x) &amp;= \int_{\omega_{\sf t}}{\rm d}x&#39; P_{\sf t}(x&#39;) P_{({\sf t}+1){\sf t}}(x\vert x&#39;) \label{eq:master-x-cont-markov} \,.\end{aligned}\]</span> It’s also easy to show that Eq. (<a href="#eq:master-x-cont-kramers-moyal" data-reference-type="ref" data-reference="eq:master-x-cont-kramers-moyal">[eq:master-x-cont-kramers-moyal]</a>) naturally simplifies into the more usually applied Kramers-Moyal expansion when considering a Markovian process — you just remove the sum over <span class="math inline">\({\sf t}&#39;\)</span> and the <span class="math inline">\(1/{\sf t}\)</span> normalisation factor.</p>
<p>Note that an analog of Eq. (<a href="#eq:master-x-cont" data-reference-type="ref" data-reference="eq:master-x-cont">[eq:master-x-cont]</a>) exists for discrete state spaces as well. We just need to replace the integral with a sum and the schematic would look something like this <span class="math display">\[\begin{aligned}
P_{{\sf t}+1}(x) &amp;= \frac{1}{{\sf t}}\sum_{{\sf t}&#39;=0}^{\sf t}\sum_{\omega_{{\sf t}&#39;}} P_{{\sf t}&#39;}(x&#39;) P_{({\sf t}+1){\sf t}&#39;}(x \vert x&#39;) \label{eq:master-x-disc} \,,\end{aligned}\]</span> where we note that the <span class="math inline">\(P\)</span>’s in the expression above all now refer to <em>probability mass functions</em>. Because the state space is now discrete, we cannot immediately intuit an approximative expansion from this expression.</p>
<p>Ok, as a brief aside; if one is really determined to use a similar approach to the one we derived above, it’s quite straightforward to rewrite it in terms of continuous-valued characteristic functions like so <span class="math display">\[\begin{aligned}
\varphi_{{\sf t}+1}(s) &amp;= \frac{1}{{\sf t}}\sum_{{\sf t}&#39;=0}^{\sf t}\int_{\ell_{{\sf t}&#39;}}{\rm d}s&#39; {\cal C}(s&#39;) \varphi_{{\sf t}&#39;}(s&#39;) \varphi_{({\sf t}+1){\sf t}&#39;}(s \vert s&#39;) \label{eq:master-x-disc-char} \\
{\cal C}(s&#39;) &amp;= \frac{1}{(2\pi )^d}\sum_{\omega_{{\sf t}&#39;}}e^{-i(s&#39;\cdot x&#39;)} \,,\end{aligned}\]</span> where <span class="math inline">\(\ell_{{\sf t}&#39;}\)</span> defines all the continuous values that the vector <span class="math inline">\(s&#39;\)</span> can possibly have at time <span class="math inline">\({\sf t}&#39;\)</span>. In the expression above, <span class="math inline">\({\cal C}(s&#39;)\)</span> acts like is a kind of comb<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> to map the continuous frequency domain of <span class="math inline">\(s&#39;\)</span> onto the discrete state space of <span class="math inline">\(x&#39;\)</span>. Note also that <span class="math inline">\({\cal C}(s&#39;)\)</span> uses the imaginary number <span class="math inline">\(i\)</span> and, to be visually tidier, the dot product notation <span class="math inline">\(a\cdot b\)</span> just means the sum of vector elements: <span class="math inline">\(a\cdot b = \sum_{\forall k}a^kb^k\)</span>. In principle, one can perform an approximative expansion on Eq. (<a href="#eq:master-x-disc-char" data-reference-type="ref" data-reference="eq:master-x-disc-char">[eq:master-x-disc-char]</a>) like we did for continuous state spaces. This isn’t always the most practical way of analysing the system though.</p>
<p>We have one more important example to discuss and then we can cap off this analysis subsection. In the even-simpler case where <span class="math inline">\(x\)</span> is just a vector of binary ‘on’ or ‘off’ states, Eq. (<a href="#eq:master-x-disc" data-reference-type="ref" data-reference="eq:master-x-disc">[eq:master-x-disc]</a>) reduces to <span class="math display">\[\begin{aligned}
P^i_{{\sf t}+1} &amp;= \frac{1}{{\sf t}}\sum_{{\sf t}&#39;=0}^{\sf t} \sum_{j=1}^d P^j_{{\sf t}&#39;} P^{ij}_{({\sf t}+1){\sf t}&#39;} = \frac{1}{{\sf t}}\sum_{{\sf t}&#39;=0}^{\sf t} \sum_{j=1}^d \big[ P^j_{{\sf t}&#39;} A^{ij}_{({\sf t}+1){\sf t}&#39;} + (1-P^j_{{\sf t}&#39;}) B^{ij}_{({\sf t}+1){\sf t}&#39;} \big] \label{eq:master-x-disc-binary}\,,\end{aligned}\]</span> where <span class="math inline">\(P^i_{{\sf t}&#39;}\)</span> now represents the probability that element <span class="math inline">\(x^i=1\)</span> (is ‘on’) at time <span class="math inline">\({\sf t}&#39;\)</span>. The matrices <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are defined as conditional probabilities where the previous state in time <span class="math inline">\(P^j_{{\sf t}&#39;}\)</span> was either ‘on’ or ‘off’, respectively.</p>
<h3 id="software-design">Software design</h3>
<p>So I’ve proposed a computational formalism and done a bit of analysis on it to demonstrate that it can cope with a variety of different stochastic phenomena. Now I think we’re ready to summarise what we want the stochadex software package to be able to do. But what’s so complicated about Eq. (<a href="#eq:x-step-def" data-reference-type="ref" data-reference="eq:x-step-def">[eq:x-step-def]</a>)? Can’t we just implement an iterative algorithm with a single function? It’s true that the fundamental concept is very straightforward, but as I’ll discuss in due course; the stochadex needs to have a lot of configurable features so that it’s applicable in different situations. Ideally, the stochadex sampler should be designed to try and maintain a balance between performance and flexibility of utilisation.</p>
<p>If we begin with the obvious first set of criteria; we want to be able to freely configure the iteration function <span class="math inline">\(F\)</span> of Eq. (<a href="#eq:x-step-def" data-reference-type="ref" data-reference="eq:x-step-def">[eq:x-step-def]</a>) and the timestep function <span class="math inline">\(t\)</span> of Eq. (<a href="#eq:t-steps-sum" data-reference-type="ref" data-reference="eq:t-steps-sum">[eq:t-steps-sum]</a>) so that any process we want can be described. The point at which a simulation stops can also depend on some algorithm termination condition which the user should be able to specify up-front.</p>
<p>Once someone has written the code to create these functions for the stochadex, I want to then be able to recall them in future only with configuration files while maintaining the possibility of changing their simulation run parameters. This flexibility should facilitate our uses for the simulation later in the book, and from this perspective it also makes sense that the parameters should include the random seed and initial state value.</p>
<p>The state history matrix <span class="math inline">\(X\)</span> should be configurable in terms of its number of rows — what we’ll call the ‘state width’ — and its number of columns — what we’ll call the ‘state history depth’. If we were to keep increasing the state width up to millions of elements or more, it’s likely that on most machines the algorithm performance would grind to a halt when trying to iterate over the resulting <span class="math inline">\(X\)</span> within a single thread. Hence, before the algorithm or its performance in any more detail, we can pre-empt the requirement that <span class="math inline">\(X\)</span> should represented in computer memory by a set of partitioned matrices which are all capable of communicating to one-another downstream. In this paradigm, I’d like the user to be able to configure which state partitions are able to communicate with each other without having to write any new code.</p>
<p>For convenience, it seems sensible to also make the outputs from stochadex runs configurable. A user should be able to change the form of output that they want through, e.g., some specified function of <span class="math inline">\(X\)</span> at the time of outputting data. The times that the stochadex should output this data can also be decided by some user-specified condition so that the frequency of output is fully configurable as well.</p>
<figure>
<img src="images/stochadex-data-types.drawio.png" id="fig:data-types-design" style="width:15cm" alt="" /><figcaption>A relational summary of the core data types in the stochadex.</figcaption>
</figure>
<p>In summary, I’ve put together a schematic of data types and their relationships in Fig. <a href="#fig:data-types-design" data-reference-type="ref" data-reference="fig:data-types-design">1.4</a>. In this diagram there is some indication of the data type that I propose to store each piece information in (in Go syntax), and the diagram as a whole should serve as a useful guide to the basic structure of configuration files for the stochadex.</p>
<p>It’s clear that in order to simulate Eq. (<a href="#eq:x-step-def" data-reference-type="ref" data-reference="eq:x-step-def">[eq:x-step-def]</a>), we need an interative algorithm which reapplies a user-specified function to the continually-updated history. But let’s now return to the point I made earlier about how the performance of such an algorithm will depend on the size of the state history matrix <span class="math inline">\(X\)</span>. The key bit of the algorithm design that isn’t so straightforward is: how do we sucessfully split this state history up into separate partitions in memory while still enabling them to communicate effectively with each other? Other generalised simulation frameworks — such as SimPy <span class="citation" data-cites="simpy">[16]</span>, StoSpa <span class="citation" data-cites="stospa">[17]</span> and FLAME GPU <span class="citation" data-cites="flamegpu">[18]</span> — have all approached this problem in different ways, and with different software architectures.</p>
<p>In Fig. <a href="#fig:loop-design" data-reference-type="ref" data-reference="fig:loop-design">1.5</a> I’ve illustrated what a loop involving two separate state partitions looks like in the stochadex simulator. Each parition is handled by concurrently running execution threads of the same process, while a separate process is used to handle the outputs from the algorithm. While this diagram illustrates only a single use for multiple processes, it’s obviously true that we may run many of these whole diagrams at once on a multicore machine to generate a batch of independent ensembles if necessary.</p>
<figure>
<img src="images/stochadex-loop.drawio.png" id="fig:loop-design" style="width:15cm" alt="" /><figcaption>A loop of the stochadex simulation algorithm with two state partitions.</figcaption>
</figure>
<h3 id="implementation-details">Implementation details</h3>
<p>Now that the design of the algorithm and its basic data types have been outlined, we can finally turn to the implementation details. As I mentioned in the introduction, most of the core software in this book has been written in Go — the main reason for this is mostly because it is a performant language that I enjoy developing with. More objectively, the key feature of Go that made it attractive for building the stochadex are its lightweight concurrency primitives called ‘goroutines’ <span class="citation" data-cites="goroutines">[19]</span> which made it easy and quick to piece together a scalable pipeline without excessive head-scratching. Ideal for projects in your limited free time!</p>
<h2 id="simulating-a-financial-market">Simulating a financial market</h2>
<p><span><strong>Concept.</strong></span> The idea here is to use the Q-Hawkes processes and the Bouchaud work to come up with some interesting simulations of financial markets.</p>
<h3 id="introducing-q-hawkes-processes">Introducing Q-Hawkes processes</h3>
<h2 id="quantum-jumps-on-generic-networks">Quantum jumps on generic networks</h2>
<p><span><strong>Concept.</strong></span> The idea is to follow this sort of thing <a href="https://en.wikipedia.org/wiki/Quantum_jump_method">here</a> to simulate the Lindblad equation over an arbitrary network of entangled states.</p>
<h3 id="the-lindblad-equation">The Lindblad equation</h3>
<h1 id="how-do-we-then-learnidentify-the-answer-to-part-1-from-real-world-data"> How do we then learn/identify the answer to Part 1 from real-world data?</h1>
<h2 id="empirical-dynamical-emulators">Empirical dynamical emulators</h2>
<p><span><strong>Concept.</strong></span> The idea here is to leverage our probabilistic formalism to be able to empirically emulate a wide variety stochastic phenomena within a generalised framework.</p>
<h2 id="inferring-dynamical-2d-maps">Inferring dynamical 2D maps</h2>
<p><span><strong>Concept.</strong></span> The idea here is</p>
<h3 id="adapting-the-stochadex-formalism">Adapting the stochadex formalism</h3>
<h2 id="learning-from-ants-on-curved-surfaces">Learning from ants on curved surfaces</h2>
<p><span><strong>Concept.</strong></span> The idea here is</p>
<h3 id="diffusive-limits-for-ant-interactions">Diffusive limits for ant interactions</h3>
<h2 id="hydrodynamic-ensembles-from-input-data">Hydrodynamic ensembles from input data</h2>
<p><span><strong>Concept.</strong></span> The idea here is</p>
<h3 id="the-boltzmannnavier-stokes-equations">The Boltzmann/Navier-Stokes equations</h3>
<h2 id="generalised-statistical-inference-tools">Generalised statistical inference tools</h2>
<p><span><strong>Concept.</strong></span> The idea here is to extend the stochadex with tools for very generalised statistical inference (ABC algorithms and the like) that will work in nearly every situation. Probably need to exploit the phase space analogy of the formalism.</p>
<h3 id="likelihood-free-methods">Likelihood-free methods</h3>
<h1 id="how-do-we-simulate-a-general-set-of-control-policies-to-interact-with-the-answer-to-part-1"> How do we simulate a general set of control policies to interact with the answer to Part 1?</h1>
<h2 id="interacting-with-systems-in-general">Interacting with systems in general</h2>
<p><span><strong>Concept.</strong></span> The idea here is</p>
<h3 id="parameterising-general-interactions">Parameterising general interactions</h3>
<h2 id="angling-for-freshwater-fish">Angling for freshwater fish</h2>
<p><span><strong>Concept.</strong></span> The idea here is</p>
<h3 id="a-large-scale-lotka-volterra-model">A large-scale Lotka-Volterra model</h3>
<p>Inspired by the empirical dynamical modelling approach to sockeye salmon in Ref. <span class="citation" data-cites="ye2015equation">[20]</span>, but also desiring a generative model which has some link to the classic causal models promoted by mathematical ecology; the goal here is to create and calibrate a stochastic model which predicts the fish counts, weights, lengths and ages for each species in each area based on the past system states. To do this, we will combine some well-known models from mathematical ecology with supervised learning.</p>
<p>The one-step master equation for the proposed stochastic simulation is given implictly by</p>
<p><span class="math display">\[\begin{aligned}
\frac{{\rm d}}{{\rm d} t} P(\dots, n_{i}, \dots, t) &amp;= \sum_{\forall i}{\cal T}^{+}_{i}(\dots, n_i-1, \dots, {\sf f}, t)P(\dots, n_{i}-1, \dots, t) \\
&amp;+ \sum_{\forall i}{\cal T}^{-}_{i}(\dots, n_i+1, \dots, {\sf f}, t)P(\dots, n_{i}+1, \dots, t) \\
&amp;- \sum_{\forall i}\bigg[ {\cal T}^{+}_{i}(\dots, n_i, \dots, {\sf f}, t) + {\cal T}^{-}_{i}(\dots, n_i, \dots, {\sf f}, t) \bigg] P(\dots, n_{i}, \dots,t) \,,\end{aligned}\]</span></p>
<p>where the time <span class="math inline">\(t\)</span> is defined in units of years and <span class="math inline">\({\cal T}^{+}_{i}\)</span> and <span class="math inline">\({\cal T}^{-}_{i}\)</span> are the transition coefficients for the <span class="math inline">\(i\)</span>-th species, which depend not only on the counts for all species <span class="math inline">\(n_1, n_2, \dots\)</span>, but also (in principle) on a larger feature space <span class="math inline">\({\sf f}\)</span> generated by the available data up to time <span class="math inline">\(t\)</span>.</p>
<p>The famous Lotka-Volterra system, with some modficiations for fishing and a larger set of species, would suggest transition coefficients of the form</p>
<p><span class="math display">\[\begin{aligned}
{\cal T}^{+}_{i}(\dots, n_i, \dots, {\sf f}, t) = {\cal T}^{+}_{i}(\dots, n_i, \dots) &amp;= \Lambda_{i}(n_{i}) + n_{i}\alpha_{i}\sum_{\forall i&#39; \, {\sf prey}}n_{i&#39;}\\
{\cal T}^{-}_{i}(\dots, n_i, \dots, {\sf f}, t) = {\cal T}^{-}_{i}(\dots, n_i, \dots) &amp;= n_{i}\mu_{i} +  n_{i}\gamma_{i} + n_{i}\beta_{i} \sum_{\forall i&#39; \, {\sf pred}} n_{i&#39;} \,,\end{aligned}\]</span></p>
<p>where: <span class="math inline">\(\Lambda_{i}(n_{i}) = \tilde{\Lambda_{i}}n_{i}e^{-\lambda_i(n_{i}-1)}\)</span> is the density-dependent birth rate; <span class="math inline">\(\mu_{i}\)</span> is the species death rate; <span class="math inline">\(\alpha_{i}\)</span> is the increase in the baseline birth rate per fish caused by the increase in prey population; <span class="math inline">\(\beta_{i}\)</span> is the rate per fish of predation of the species; and <span class="math inline">\(\gamma_{i}\)</span> accounts for the rate of recreational fishing per fish of the species. To approach the present data-driven simulation problem, we’re going to generalise this model by training <span class="math inline">\({\cal T}^{+}_{i}(\dots, n_i, \dots, {\sf f}, t)\)</span> and <span class="math inline">\({\cal T}^{-}_{i}(\dots, n_i, \dots, {\sf f}, t)\)</span> directly from the data and generated features.</p>
<p>Look into the likelihood from, e.g., an electrofishing survey such as in Ref. <span class="citation" data-cites="envagency2015">[21]</span>...</p>
<p><span class="math display">\[\begin{aligned}
{\sf Likelihood} &amp;= \sum_{{\sf data}}{\rm NB}\big[{\sf data};w_{i,{\sf survey}}\langle n_i(t_{{\sf data}})\rangle,k_{i,{\sf survey}}\big] \,,\end{aligned}\]</span></p>
<h2 id="managing-a-rugby-match">Managing a Rugby match</h2>
<p><span><strong>Concept.</strong></span> The idea here is</p>
<h3 id="introduction-1">Introduction</h3>
<p>Since the basic game engine will run using the <a href="https://github.com/umbralcalc/stochadex">stochadex</a> sampler, the novelties in this project are all in the design of the rugby match model itself. And, in this instance, I’m not especially keen on spending a lot of time doing detailed data analysis to come up with the most realistic values for the parameters that are dreamed up here. Even though this would also be interesting.</p>
<p>One could do this data analysis, for instance, by scraping player-level performance data from one of the excellent websites that collect live commentary data such as <a href="https://www.rugbypass.com/">rugbypass.com</a> or <a href="https://www.espn.co.uk/rugby/">espn.co.uk/rugby</a>.</p>
<p>This game is primarily a way of testing out the interface of the stochadex for other users to build projects with. This should help to both iron out some of the kinks in the design, as well as prioritise adding some more convenience methods for event-based modelling into its code base.</p>
<h3 id="designing-the-event-simulation-engine">Designing the event simulation engine</h3>
<p>We need to begin by specifying an appropriate event space to live in when simulating a rugby match. It is important at this level that events are defined in quite broadly applicable terms, as it will define the state space available to our stochastic sampler and hence the simulated game will never be allowed to exist outside of it. So, in order to capture the fully detailed range of events that are possible in a real-world match, we will need to be a little imaginative in how we define certain gameplay elements when we move through the space.</p>
<p>The diagrams below sum up what should hopefully work as a decent initial approximation while providing a little context with specific examples of play action.</p>
<figure>
<img src="images/test.drawio.png" id="fig:event-graph" style="width:8cm" alt="" /><figcaption>Simplified event graph of a rugby union match - replace with drawio.</figcaption>
</figure>
<figure>
<img src="images/test.drawio.png" id="fig:model-ideas" style="width:10cm" alt="" /><figcaption>Optional model ideas - replace with drawio.</figcaption>
</figure>
<h3 id="linking-to-player-attributes">Linking to player attributes</h3>
<h3 id="deciding-on-gameplay-actions">Deciding on gameplay actions</h3>
<h3 id="writing-the-game-itself">Writing the game itself</h3>
<h2 id="influencing-house-prices">Influencing house prices</h2>
<p><span><strong>Concept.</strong></span> The idea here is</p>
<h1 id="how-do-we-then-optimise-the-answer-to-part-3-to-achieve-a-specified-control-objective"> How do we then optimise the answer to Part 3 to achieve a specified control objective?</h1>
<h2 id="optimising-actions-for-control-objectives">Optimising actions for control objectives</h2>
<p><span><strong>Concept.</strong></span> The idea controlhere is</p>
<h2 id="resource-allocation-for-epidemics">Resource allocation for epidemics</h2>
<p><span><strong>Concept.</strong></span> The idea here is to limit the spread of some abstract epidemic through the correct time-dependent resource allocation.</p>
<h2 id="quantum-system-control">Quantum system control</h2>
<p><span><strong>Concept.</strong></span> The idea here is to follow stuff along these lines <a href="https://arxiv.org/pdf/1210.7127.pdf">here</a>.</p>
<h2 id="other-models">Other models</h2>
<p><span><strong>Concept.</strong></span> The idea here is</p>
<div id="refs" class="references" role="doc-bibliography">
<div id="ref-golang">
<p>[1] “The Go Programming Language.” <a href="https://go.dev/">https://go.dev/</a>.</p>
</div>
<div id="ref-pythonlang">
<p>[2] “The Python Programming Language.” <a href="https://www.python.org/">https://www.python.org/</a>.</p>
</div>
<div id="ref-diffusingideasbookgithub">
<p>[3] “The Diffusing Ideas GitHub Repository.” <a href="https://github.com/umbralcalc/diffusing-ideas">https://github.com/umbralcalc/diffusing-ideas</a>.</p>
</div>
<div id="ref-mitlicense">
<p>[4] “Open Source Initiative: MIT License.” <a href="https://opensource.org/licenses/MIT">https://opensource.org/licenses/MIT</a>.</p>
</div>
<div id="ref-van1992stochastic">
<p>[5] N. G. Van Kampen, <em>Stochastic processes in physics and chemistry</em>, vol. 1. Elsevier, 1992.</p>
</div>
<div id="ref-risken1996fokker">
<p>[6] H. Risken, “Fokker-planck equation,” in <em>The fokker-planck equation</em>, Springer, 1996, pp. 63–95.</p>
</div>
<div id="ref-rog-will-2000">
<p>[7] L. Rogers and D. Williams, “Diffusions, markov processes and martingales 2: Ito calculus,” vol. 1, Cambridge University Press, 2000, p. xiv+480. doi: <a href="https://doi.org/10.1017/CBO9781107590120">10.1017/CBO9781107590120</a>.</p>
</div>
<div id="ref-decreusefond1999stochastic">
<p>[8] L. Decreusefond and others, “Stochastic analysis of the fractional brownian motion,” <em>Potential analysis</em>, vol. 10, no. 2, pp. 177–214, 1999.</p>
</div>
<div id="ref-gillespie1977exact">
<p>[9] D. T. Gillespie, “Exact stochastic simulation of coupled chemical reactions,” <em>The journal of physical chemistry</em>, vol. 81, no. 25, pp. 2340–2361, 1977.</p>
</div>
<div id="ref-neyman1958statistical">
<p>[10] J. Neyman and E. L. Scott, “Statistical approach to problems of cosmology,” <em>Journal of the Royal Statistical Society: Series B (Methodological)</em>, vol. 20, no. 1, pp. 1–29, 1958.</p>
</div>
<div id="ref-hawkes1971spectra">
<p>[11] A. G. Hawkes, “Spectra of some self-exciting and mutually exciting point processes,” <em>Biometrika</em>, vol. 58, no. 1, pp. 83–90, 1971.</p>
</div>
<div id="ref-kramers1940brownian">
<p>[12] H. A. Kramers, “Brownian motion in a field of force and the diffusion model of chemical reactions,” <em>Physica</em>, vol. 7, no. 4, pp. 284–304, 1940.</p>
</div>
<div id="ref-moyal1949stochastic">
<p>[13] J. Moyal, “Stochastic processes and statistical physics,” <em>Journal of the Royal Statistical Society. Series B (Methodological)</em>, vol. 11, no. 2, pp. 150–210, 1949.</p>
</div>
<div id="ref-murphy2012machine">
<p>[14] K. P. Murphy, <em>Machine learning: A probabilistic perspective</em>. MIT press, 2012.</p>
</div>
<div id="ref-brandwood2012fourier">
<p>[15] D. Brandwood, <em>Fourier transforms in radar and signal processing</em>. Artech House, 2012.</p>
</div>
<div id="ref-simpy">
<p>[16] “SimPy: a process-based discrete-event simulation framework.” <a href="https://gitlab.com/team-simpy/simpy/">https://gitlab.com/team-simpy/simpy/</a>.</p>
</div>
<div id="ref-stospa">
<p>[17] “StoSpa: A C++ package for running stochastic simulations to generate sample paths for reaction-diffusion master equation.” <a href="https://github.com/BartoszBartmanski/StoSpa">https://github.com/BartoszBartmanski/StoSpa</a>.</p>
</div>
<div id="ref-flamegpu">
<p>[18] “FLAME GPU: A GPU accelerated agent-based simulation library for domain independent complex systems simulation.” <a href="https://github.com/FLAMEGPU/FLAMEGPU2/">https://github.com/FLAMEGPU/FLAMEGPU2/</a>.</p>
</div>
<div id="ref-goroutines">
<p>[19] “A Tour of Go: Goroutines.” <a href="https://go.dev/tour/concurrency/1">https://go.dev/tour/concurrency/1</a>.</p>
</div>
<div id="ref-ye2015equation">
<p>[20] H. Ye <em>et al.</em>, “Equation-free mechanistic ecosystem forecasting using empirical dynamic modeling,” <em>Proceedings of the National Academy of Sciences</em>, vol. 112, no. 13, pp. E1569–E1576, 2015.</p>
</div>
<div id="ref-envagency2015">
<p>[21] “Electrofishing to assess a river’s health.” <a href="https://environmentagency.blog.gov.uk/2015/10/29/electrofishing-to-assess-a-rivers-health/">https://environmentagency.blog.gov.uk/2015/10/29/electrofishing-to-assess-a-rivers-health/</a>.</p>
</div>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>For example, thinking more in terms of ‘matrices’ and less about ‘operators’.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>The repositories will always be somewhere on this list: <a href="https://github.com/umbralcalc?tab=repositories">https://github.com/umbralcalc?tab=repositories</a>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Or memory at least within some window.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>Which would implictly give <span class="math inline">\(S^{i}_{{\sf t}+1}(X&#39;,{\sf t}) = (X^i_{{\sf t}+1}+X^i_{\sf t})(W^i_{{\sf t}+1}-W^i_{\sf t}) / 2\)</span> for Eq. (<a href="#eq:gbm" data-reference-type="ref" data-reference="eq:gbm">[eq:gbm]</a>).<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>This is very similar to how a ‘Dirac comb’ works in signal processing <span class="citation" data-cites="brandwood2012fourier">[15]</span>.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<div class="w3-container w3-black w3-center w3-opacity w3-padding-64">
  <h1 class="w3-margin w3-xlarge">Quote of the day: live life</h1>
</div>
<script>
// Used to toggle the menu on small screens when clicking on the menu button
function myFunction() {
  var x = document.getElementById("navDemo");
  if (x.className.indexOf("w3-show") == -1) {
    x.className += " w3-show";
  } else { 
    x.className = x.className.replace(" w3-show", "");
  }
}
</script>
</body>
</html>